{"ast":null,"code":"import React from'react';import{Prism as SyntaxHighlighter}from'react-syntax-highlighter';import{oneDark}from'react-syntax-highlighter/dist/cjs/styles/prism';import'./CodeBlock.css';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const CodeBlock=()=>{const codeString=`class Graph {\n        constructor() {\n            this.adjacencyList = {}; // список смежности аля\n        }\n\n        //Добавить вершину\n        addEdge(start, end, weight) {\n            if (!this.adjacencyList[start]) {\n                this.adjacencyList[start] = [];\n            }\n            this.adjacencyList[start].push({ node: end, weight: weight }); \n            // в список смежности к вершине вставляем узел (end) и вес пути к нему\n\n        }\n\n        getNeighbors(node) {\n            return this.adjacencyList[node] || [];\n        }\n\n        //Ищем кратчайший путь от 1 вершины до другой по Дейкстру\n        findShortestPath(start, end) { \n            const distances = {}; // расстояния\n            const previous = {}; // предыдущие\n            const queue = new PriorityQueue(); // Очередь с приоритетом\n            \n            for (const edge in this.adjacencyList) {\n                distances[edge] = Infinity;\n                previous[edge] = null;\n            } // Сперва проставили все расстояния как бесконечность, а предыдущие пустые\n            \n            distances[start] = 0;\n            queue.enqueue(start, 0); // Добавили в приоритетную очередь первую вершину\n            \n            while (!queue.isEmpty()) {\n                const currentEdge = queue.dequeue(); \n                \n                \n                if (currentEdge === end) {\n                    const path = [];\n                    let temp = currentEdge;\n                    while (temp) {\n                        path.push(temp);\n                        temp = previous[temp];\n                    }\n                    return path.reverse();\n                }\n                \n                // for .. of - neighbor будет мини объектиком {node:.. ,weight:..}\n                for (const neighbor of this.getNeighbors(currentEdge)) { \n                    const alt = distances[currentEdge] + neighbor.weight;\n                    if (alt < distances[neighbor.node]) {\n                        distances[neighbor.node] = alt; // дистанция от соседнего узла\n                        previous[neighbor.node] = currentEdge; // предыдущая вершина для соседнего узла  - эта вершина\n                        queue.enqueue(neighbor.node, alt); // добавляем в приоритетную очередь \n                                                           // [вершина, дистанция до нее] (приоритет по дистанции как раз)\n                    }\n                }\n            }\n            \n            return []; // Если путь не найден\n        }\n\n        kShortestPaths(start, end, k) {\n            let removedEdges = []\n            const firstPath = this.findShortestPath(start, end);\n            const paths = [firstPath.join('')];\n            const pathCosts = [this.calculatePathCost(firstPath)];\n            const uniquePaths = new Set(paths.map(path => path)); // Используем Set для уникальности\n\n            for (let i = 0; i < Object.values(Object.values(graph)[0]).length; i++) {\n                let newPaths = [];\n                for (let j = 0; j < paths.length; j++) {\n                    const path = paths[j];\n                    const pathCost = pathCosts[j];\n\n                    for (let n = 0; n < path.length - 1; n++) {\n                        const tempNode = path[n];\n                        const rootPath = path.slice(0, n + 1);\n                        const removedEdges = this.removeEdges(rootPath);\n                        removedEdges.push(removedEdges);\n\n                        //const tempPath = this.findShortestPath(start, end);\n                        const tempPath = this.findShortestPath(tempNode, end);\n                \n\n                        if (tempPath.length > 0 ) {\n\n                            const totalPath = rootPath + tempPath.slice(1).join(\"\");\n                            const totalCost = this.calculatePathCost(totalPath);\n                            \n                            const pathKey = totalPath;\n                            if (!uniquePaths.has(pathKey) && (totalPath[0] === start) && (totalPath[totalPath.length-1] === end) ) {\n                                newPaths.push({ path: totalPath, cost: totalCost });\n                                uniquePaths.add(pathKey); \n                            }\n                        }\n\n                        \n                    }\n                }\n\n                this.restoreEdges(removedEdges);\n\n                // Сортируем новые пути по стоимости\n                newPaths.sort((a, b) => a.cost - b.cost);\n\n                // Добавляем только уникальные пути\n                for (const newPath of newPaths) {\n                    if (paths.length < k) {\n                        paths.push(newPath.path);\n                        pathCosts.push(newPath.cost);\n                    } else {\n                        break; // Если мы уже нашли k путей, выходим\n                    }\n                }\n\n                if (paths.length >= k) break;\n            }\n\n            return paths.slice(0, k);\n        }\n\n\n\n        calculatePathCost(path) {\n            let cost = 0;\n            for (let i = 0; i < path.length - 1; i++) {\n                const neighbors = this.getNeighbors(path[i]);\n                for (const neighbor of neighbors) {\n                    if (neighbor.node === path[i + 1]) {\n                        cost += neighbor.weight;\n                        break;\n                    }\n                }\n            }\n            return cost;\n        }\n\n\n\n        removeEdges(rootPath) {\n            const removedEdges = [];\n            for (let i = 0; i < rootPath.length - 1; i++) {\n                const start = rootPath[i];\n                const end = rootPath[i + 1];\n                const neighbors = this.getNeighbors(start);\n                for (const neighbor of neighbors) {\n                    if (neighbor.node === end) {\n                        removedEdges.push({ start: start, end: end, weight: neighbor.weight });\n                        this.adjacencyList[start] = this.adjacencyList[start].filter(edge => edge.node !== end);\n                        break;\n                    }\n                }\n            }\n            return removedEdges;\n        }\n\n        restoreEdges(removedEdges) {\n            for (const edge of removedEdges) {\n                this.addEdge(edge.start, edge.end, edge.weight);\n            }\n        }\n    }\n\n    class PriorityQueue {\n        // создание нового экземпляра\n        constructor() {\n            this.items = [];\n        }\n\n        // устанавливает новый элемент в очередь по приоритету\n        enqueue(element, priority) {\n            this.items.push({ element, priority });\n            this.items.sort((a, b) => a.priority - b.priority);\n        }\n\n        // удаляет самый приоритетный элемент - возвращает его же\n        dequeue() {\n            return this.items.shift();\n        }\n\n        // проверка на пустоту\n        isEmpty() {\n            return this.items.length === 0;\n        }\n    }\n    `;return/*#__PURE__*/_jsxs(\"div\",{class:\"main_CodeBlock\",children:[/*#__PURE__*/_jsx(\"h2\",{children:\"\\u041F\\u043E\\u0438\\u0441\\u043A k \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u0445 \\u043F\\u0443\\u0442\\u0435\\u0439 \\u0432 \\u0433\\u0440\\u0430\\u0444\\u0435 \\u043D\\u0430 JavaScript\"}),/*#__PURE__*/_jsx(SyntaxHighlighter,{language:\"javascript\",style:oneDark,showLineNumbers:true,children:codeString})]});};export default CodeBlock;","map":{"version":3,"names":["React","Prism","SyntaxHighlighter","oneDark","jsx","_jsx","jsxs","_jsxs","CodeBlock","codeString","class","children","language","style","showLineNumbers"],"sources":["/home/voold/Desktop/tg/src/CodeBlock.js"],"sourcesContent":["import React from 'react';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { oneDark } from 'react-syntax-highlighter/dist/cjs/styles/prism';\nimport './CodeBlock.css';\n\n\nconst CodeBlock = () => {\n    const codeString = `class Graph {\n        constructor() {\n            this.adjacencyList = {}; // список смежности аля\n        }\n\n        //Добавить вершину\n        addEdge(start, end, weight) {\n            if (!this.adjacencyList[start]) {\n                this.adjacencyList[start] = [];\n            }\n            this.adjacencyList[start].push({ node: end, weight: weight }); \n            // в список смежности к вершине вставляем узел (end) и вес пути к нему\n\n        }\n\n        getNeighbors(node) {\n            return this.adjacencyList[node] || [];\n        }\n\n        //Ищем кратчайший путь от 1 вершины до другой по Дейкстру\n        findShortestPath(start, end) { \n            const distances = {}; // расстояния\n            const previous = {}; // предыдущие\n            const queue = new PriorityQueue(); // Очередь с приоритетом\n            \n            for (const edge in this.adjacencyList) {\n                distances[edge] = Infinity;\n                previous[edge] = null;\n            } // Сперва проставили все расстояния как бесконечность, а предыдущие пустые\n            \n            distances[start] = 0;\n            queue.enqueue(start, 0); // Добавили в приоритетную очередь первую вершину\n            \n            while (!queue.isEmpty()) {\n                const currentEdge = queue.dequeue(); \n                \n                \n                if (currentEdge === end) {\n                    const path = [];\n                    let temp = currentEdge;\n                    while (temp) {\n                        path.push(temp);\n                        temp = previous[temp];\n                    }\n                    return path.reverse();\n                }\n                \n                // for .. of - neighbor будет мини объектиком {node:.. ,weight:..}\n                for (const neighbor of this.getNeighbors(currentEdge)) { \n                    const alt = distances[currentEdge] + neighbor.weight;\n                    if (alt < distances[neighbor.node]) {\n                        distances[neighbor.node] = alt; // дистанция от соседнего узла\n                        previous[neighbor.node] = currentEdge; // предыдущая вершина для соседнего узла  - эта вершина\n                        queue.enqueue(neighbor.node, alt); // добавляем в приоритетную очередь \n                                                           // [вершина, дистанция до нее] (приоритет по дистанции как раз)\n                    }\n                }\n            }\n            \n            return []; // Если путь не найден\n        }\n\n        kShortestPaths(start, end, k) {\n            let removedEdges = []\n            const firstPath = this.findShortestPath(start, end);\n            const paths = [firstPath.join('')];\n            const pathCosts = [this.calculatePathCost(firstPath)];\n            const uniquePaths = new Set(paths.map(path => path)); // Используем Set для уникальности\n\n            for (let i = 0; i < Object.values(Object.values(graph)[0]).length; i++) {\n                let newPaths = [];\n                for (let j = 0; j < paths.length; j++) {\n                    const path = paths[j];\n                    const pathCost = pathCosts[j];\n\n                    for (let n = 0; n < path.length - 1; n++) {\n                        const tempNode = path[n];\n                        const rootPath = path.slice(0, n + 1);\n                        const removedEdges = this.removeEdges(rootPath);\n                        removedEdges.push(removedEdges);\n\n                        //const tempPath = this.findShortestPath(start, end);\n                        const tempPath = this.findShortestPath(tempNode, end);\n                \n\n                        if (tempPath.length > 0 ) {\n\n                            const totalPath = rootPath + tempPath.slice(1).join(\"\");\n                            const totalCost = this.calculatePathCost(totalPath);\n                            \n                            const pathKey = totalPath;\n                            if (!uniquePaths.has(pathKey) && (totalPath[0] === start) && (totalPath[totalPath.length-1] === end) ) {\n                                newPaths.push({ path: totalPath, cost: totalCost });\n                                uniquePaths.add(pathKey); \n                            }\n                        }\n\n                        \n                    }\n                }\n\n                this.restoreEdges(removedEdges);\n\n                // Сортируем новые пути по стоимости\n                newPaths.sort((a, b) => a.cost - b.cost);\n\n                // Добавляем только уникальные пути\n                for (const newPath of newPaths) {\n                    if (paths.length < k) {\n                        paths.push(newPath.path);\n                        pathCosts.push(newPath.cost);\n                    } else {\n                        break; // Если мы уже нашли k путей, выходим\n                    }\n                }\n\n                if (paths.length >= k) break;\n            }\n\n            return paths.slice(0, k);\n        }\n\n\n\n        calculatePathCost(path) {\n            let cost = 0;\n            for (let i = 0; i < path.length - 1; i++) {\n                const neighbors = this.getNeighbors(path[i]);\n                for (const neighbor of neighbors) {\n                    if (neighbor.node === path[i + 1]) {\n                        cost += neighbor.weight;\n                        break;\n                    }\n                }\n            }\n            return cost;\n        }\n\n\n\n        removeEdges(rootPath) {\n            const removedEdges = [];\n            for (let i = 0; i < rootPath.length - 1; i++) {\n                const start = rootPath[i];\n                const end = rootPath[i + 1];\n                const neighbors = this.getNeighbors(start);\n                for (const neighbor of neighbors) {\n                    if (neighbor.node === end) {\n                        removedEdges.push({ start: start, end: end, weight: neighbor.weight });\n                        this.adjacencyList[start] = this.adjacencyList[start].filter(edge => edge.node !== end);\n                        break;\n                    }\n                }\n            }\n            return removedEdges;\n        }\n\n        restoreEdges(removedEdges) {\n            for (const edge of removedEdges) {\n                this.addEdge(edge.start, edge.end, edge.weight);\n            }\n        }\n    }\n\n    class PriorityQueue {\n        // создание нового экземпляра\n        constructor() {\n            this.items = [];\n        }\n\n        // устанавливает новый элемент в очередь по приоритету\n        enqueue(element, priority) {\n            this.items.push({ element, priority });\n            this.items.sort((a, b) => a.priority - b.priority);\n        }\n\n        // удаляет самый приоритетный элемент - возвращает его же\n        dequeue() {\n            return this.items.shift();\n        }\n\n        // проверка на пустоту\n        isEmpty() {\n            return this.items.length === 0;\n        }\n    }\n    `;\n\n\n    return (\n        <div class = \"main_CodeBlock\">\n            <h2>Поиск k наименьших путей в графе на JavaScript</h2>\n            <SyntaxHighlighter language=\"javascript\" style={oneDark} showLineNumbers={true}>\n                {codeString}\n            </SyntaxHighlighter>\n        </div>\n    );\n};\n\nexport default CodeBlock;\n"],"mappings":"AAAA,MAAO,CAAAA,KAAK,KAAM,OAAO,CACzB,OAASC,KAAK,GAAI,CAAAC,iBAAiB,KAAQ,0BAA0B,CACrE,OAASC,OAAO,KAAQ,gDAAgD,CACxE,MAAO,iBAAiB,CAAC,OAAAC,GAAA,IAAAC,IAAA,CAAAC,IAAA,IAAAC,KAAA,yBAGzB,KAAM,CAAAC,SAAS,CAAGA,CAAA,GAAM,CACpB,KAAM,CAAAC,UAAU,CAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,CAGD,mBACIF,KAAA,QAAKG,KAAK,CAAG,gBAAgB,CAAAC,QAAA,eACzBN,IAAA,OAAAM,QAAA,CAAI,4LAA8C,CAAI,CAAC,cACvDN,IAAA,CAACH,iBAAiB,EAACU,QAAQ,CAAC,YAAY,CAACC,KAAK,CAAEV,OAAQ,CAACW,eAAe,CAAE,IAAK,CAAAH,QAAA,CAC1EF,UAAU,CACI,CAAC,EACnB,CAAC,CAEd,CAAC,CAED,cAAe,CAAAD,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}