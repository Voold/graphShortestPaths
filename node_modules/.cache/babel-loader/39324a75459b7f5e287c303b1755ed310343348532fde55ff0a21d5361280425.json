{"ast":null,"code":"var _jsxFileName = \"/home/voold/Desktop/tg/src/CodeBlock.js\";\nimport React from 'react';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { oneDark } from 'react-syntax-highlighter/dist/cjs/styles/prism';\nimport './CodeBlock.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CodeBlock = () => {\n  const codeString = `class Graph {\n        constructor() {\n            this.adjacencyList = {}; // список смежности аля\n        }\n\n        //Добавить вершину\n        addEdge(start, end, weight) {\n            if (!this.adjacencyList[start]) {\n                this.adjacencyList[start] = [];\n            }\n            this.adjacencyList[start].push({ node: end, weight: weight }); \n            // в список смежности к вершине вставляем узел (end) и вес пути к нему\n\n        }\n\n        getNeighbors(node) {\n            return this.adjacencyList[node] || [];\n        }\n\n        //Ищем кратчайший путь от 1 вершины до другой по Дейкстру\n        findShortestPath(start, end) { \n            const distances = {}; // расстояния\n            const previous = {}; // предыдущие\n            const queue = new PriorityQueue(); // Очередь с приоритетом\n            \n            for (const edge in this.adjacencyList) {\n                distances[edge] = Infinity;\n                previous[edge] = null;\n            } // Сперва проставили все расстояния как бесконечность, а предыдущие пустые\n            \n            distances[start] = 0;\n            queue.enqueue(start, 0); // Добавили в приоритетную очередь первую вершину\n            \n            while (!queue.isEmpty()) {\n                const currentEdge = queue.dequeue(); \n                \n                \n                if (currentEdge === end) {\n                    const path = [];\n                    let temp = currentEdge;\n                    while (temp) {\n                        path.push(temp);\n                        temp = previous[temp];\n                    }\n                    return path.reverse();\n                }\n                \n                // for .. of - neighbor будет мини объектиком {node:.. ,weight:..}\n                for (const neighbor of this.getNeighbors(currentEdge)) { \n                    const alt = distances[currentEdge] + neighbor.weight;\n                    if (alt < distances[neighbor.node]) {\n                        distances[neighbor.node] = alt; // дистанция от соседнего узла\n                        previous[neighbor.node] = currentEdge; // предыдущая вершина для соседнего узла  - эта вершина\n                        queue.enqueue(neighbor.node, alt); // добавляем в приоритетную очередь \n                                                           // [вершина, дистанция до нее] (приоритет по дистанции как раз)\n                    }\n                }\n            }\n            \n            return []; // Если путь не найден\n        }\n\n        kShortestPaths(start, end, k) {\n            let removedEdges = []\n            const firstPath = this.findShortestPath(start, end);\n            const paths = [firstPath.join('')];\n            const pathCosts = [this.calculatePathCost(firstPath)];\n            const uniquePaths = new Set(paths.map(path => path)); // Используем Set для уникальности\n\n            for (let i = 0; i < Object.values(Object.values(graph)[0]).length; i++) {\n                let newPaths = [];\n                for (let j = 0; j < paths.length; j++) {\n                    const path = paths[j];\n                    const pathCost = pathCosts[j];\n\n                    for (let n = 0; n < path.length - 1; n++) {\n                        const tempNode = path[n];\n                        const rootPath = path.slice(0, n + 1);\n                        const removedEdges = this.removeEdges(rootPath);\n                        removedEdges.push(removedEdges);\n\n                        //const tempPath = this.findShortestPath(start, end);\n                        const tempPath = this.findShortestPath(tempNode, end);\n                \n\n                        if (tempPath.length > 0 ) {\n\n                            const totalPath = rootPath + tempPath.slice(1).join(\"\");\n                            const totalCost = this.calculatePathCost(totalPath);\n                            \n                            const pathKey = totalPath;\n                            if (!uniquePaths.has(pathKey) && (totalPath[0] === start) && (totalPath[totalPath.length-1] === end) ) {\n                                newPaths.push({ path: totalPath, cost: totalCost });\n                                uniquePaths.add(pathKey); \n                            }\n                        }\n\n                        \n                    }\n                }\n\n                this.restoreEdges(removedEdges);\n\n                // Сортируем новые пути по стоимости\n                newPaths.sort((a, b) => a.cost - b.cost);\n\n                // Добавляем только уникальные пути\n                for (const newPath of newPaths) {\n                    if (paths.length < k) {\n                        paths.push(newPath.path);\n                        pathCosts.push(newPath.cost);\n                    } else {\n                        break; // Если мы уже нашли k путей, выходим\n                    }\n                }\n\n                if (paths.length >= k) break;\n            }\n\n            return paths.slice(0, k);\n        }\n\n\n\n        calculatePathCost(path) {\n            let cost = 0;\n            for (let i = 0; i < path.length - 1; i++) {\n                const neighbors = this.getNeighbors(path[i]);\n                for (const neighbor of neighbors) {\n                    if (neighbor.node === path[i + 1]) {\n                        cost += neighbor.weight;\n                        break;\n                    }\n                }\n            }\n            return cost;\n        }\n\n\n\n        removeEdges(rootPath) {\n            const removedEdges = [];\n            for (let i = 0; i < rootPath.length - 1; i++) {\n                const start = rootPath[i];\n                const end = rootPath[i + 1];\n                const neighbors = this.getNeighbors(start);\n                for (const neighbor of neighbors) {\n                    if (neighbor.node === end) {\n                        removedEdges.push({ start: start, end: end, weight: neighbor.weight });\n                        this.adjacencyList[start] = this.adjacencyList[start].filter(edge => edge.node !== end);\n                        break;\n                    }\n                }\n            }\n            return removedEdges;\n        }\n\n        restoreEdges(removedEdges) {\n            for (const edge of removedEdges) {\n                this.addEdge(edge.start, edge.end, edge.weight);\n            }\n        }\n    }\n\n    class PriorityQueue {\n        // создание нового экземпляра\n        constructor() {\n            this.items = [];\n        }\n\n        // устанавливает новый элемент в очередь по приоритету\n        enqueue(element, priority) {\n            this.items.push({ element, priority });\n            this.items.sort((a, b) => a.priority - b.priority);\n        }\n\n        // удаляет самый приоритетный элемент - возвращает его же\n        dequeue() {\n            return this.items.shift();\n        }\n\n        // проверка на пустоту\n        isEmpty() {\n            return this.items.length === 0;\n        }\n    }\n    `;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    class: \"main_CodeBlock\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"\\u041F\\u043E\\u0438\\u0441\\u043A k \\u043D\\u0430\\u0438\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u0445 \\u043F\\u0443\\u0442\\u0435\\u0439 \\u0432 \\u0433\\u0440\\u0430\\u0444\\u0435 \\u043D\\u0430 JavaScript\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 199,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(SyntaxHighlighter, {\n      language: \"javascript\",\n      style: oneDark,\n      showLineNumbers: true,\n      children: codeString\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 200,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 198,\n    columnNumber: 9\n  }, this);\n};\n_c = CodeBlock;\nexport default CodeBlock;\nvar _c;\n$RefreshReg$(_c, \"CodeBlock\");","map":{"version":3,"names":["React","Prism","SyntaxHighlighter","oneDark","jsxDEV","_jsxDEV","CodeBlock","codeString","class","children","fileName","_jsxFileName","lineNumber","columnNumber","language","style","showLineNumbers","_c","$RefreshReg$"],"sources":["/home/voold/Desktop/tg/src/CodeBlock.js"],"sourcesContent":["import React from 'react';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { oneDark } from 'react-syntax-highlighter/dist/cjs/styles/prism';\nimport './CodeBlock.css';\n\n\nconst CodeBlock = () => {\n    const codeString = `class Graph {\n        constructor() {\n            this.adjacencyList = {}; // список смежности аля\n        }\n\n        //Добавить вершину\n        addEdge(start, end, weight) {\n            if (!this.adjacencyList[start]) {\n                this.adjacencyList[start] = [];\n            }\n            this.adjacencyList[start].push({ node: end, weight: weight }); \n            // в список смежности к вершине вставляем узел (end) и вес пути к нему\n\n        }\n\n        getNeighbors(node) {\n            return this.adjacencyList[node] || [];\n        }\n\n        //Ищем кратчайший путь от 1 вершины до другой по Дейкстру\n        findShortestPath(start, end) { \n            const distances = {}; // расстояния\n            const previous = {}; // предыдущие\n            const queue = new PriorityQueue(); // Очередь с приоритетом\n            \n            for (const edge in this.adjacencyList) {\n                distances[edge] = Infinity;\n                previous[edge] = null;\n            } // Сперва проставили все расстояния как бесконечность, а предыдущие пустые\n            \n            distances[start] = 0;\n            queue.enqueue(start, 0); // Добавили в приоритетную очередь первую вершину\n            \n            while (!queue.isEmpty()) {\n                const currentEdge = queue.dequeue(); \n                \n                \n                if (currentEdge === end) {\n                    const path = [];\n                    let temp = currentEdge;\n                    while (temp) {\n                        path.push(temp);\n                        temp = previous[temp];\n                    }\n                    return path.reverse();\n                }\n                \n                // for .. of - neighbor будет мини объектиком {node:.. ,weight:..}\n                for (const neighbor of this.getNeighbors(currentEdge)) { \n                    const alt = distances[currentEdge] + neighbor.weight;\n                    if (alt < distances[neighbor.node]) {\n                        distances[neighbor.node] = alt; // дистанция от соседнего узла\n                        previous[neighbor.node] = currentEdge; // предыдущая вершина для соседнего узла  - эта вершина\n                        queue.enqueue(neighbor.node, alt); // добавляем в приоритетную очередь \n                                                           // [вершина, дистанция до нее] (приоритет по дистанции как раз)\n                    }\n                }\n            }\n            \n            return []; // Если путь не найден\n        }\n\n        kShortestPaths(start, end, k) {\n            let removedEdges = []\n            const firstPath = this.findShortestPath(start, end);\n            const paths = [firstPath.join('')];\n            const pathCosts = [this.calculatePathCost(firstPath)];\n            const uniquePaths = new Set(paths.map(path => path)); // Используем Set для уникальности\n\n            for (let i = 0; i < Object.values(Object.values(graph)[0]).length; i++) {\n                let newPaths = [];\n                for (let j = 0; j < paths.length; j++) {\n                    const path = paths[j];\n                    const pathCost = pathCosts[j];\n\n                    for (let n = 0; n < path.length - 1; n++) {\n                        const tempNode = path[n];\n                        const rootPath = path.slice(0, n + 1);\n                        const removedEdges = this.removeEdges(rootPath);\n                        removedEdges.push(removedEdges);\n\n                        //const tempPath = this.findShortestPath(start, end);\n                        const tempPath = this.findShortestPath(tempNode, end);\n                \n\n                        if (tempPath.length > 0 ) {\n\n                            const totalPath = rootPath + tempPath.slice(1).join(\"\");\n                            const totalCost = this.calculatePathCost(totalPath);\n                            \n                            const pathKey = totalPath;\n                            if (!uniquePaths.has(pathKey) && (totalPath[0] === start) && (totalPath[totalPath.length-1] === end) ) {\n                                newPaths.push({ path: totalPath, cost: totalCost });\n                                uniquePaths.add(pathKey); \n                            }\n                        }\n\n                        \n                    }\n                }\n\n                this.restoreEdges(removedEdges);\n\n                // Сортируем новые пути по стоимости\n                newPaths.sort((a, b) => a.cost - b.cost);\n\n                // Добавляем только уникальные пути\n                for (const newPath of newPaths) {\n                    if (paths.length < k) {\n                        paths.push(newPath.path);\n                        pathCosts.push(newPath.cost);\n                    } else {\n                        break; // Если мы уже нашли k путей, выходим\n                    }\n                }\n\n                if (paths.length >= k) break;\n            }\n\n            return paths.slice(0, k);\n        }\n\n\n\n        calculatePathCost(path) {\n            let cost = 0;\n            for (let i = 0; i < path.length - 1; i++) {\n                const neighbors = this.getNeighbors(path[i]);\n                for (const neighbor of neighbors) {\n                    if (neighbor.node === path[i + 1]) {\n                        cost += neighbor.weight;\n                        break;\n                    }\n                }\n            }\n            return cost;\n        }\n\n\n\n        removeEdges(rootPath) {\n            const removedEdges = [];\n            for (let i = 0; i < rootPath.length - 1; i++) {\n                const start = rootPath[i];\n                const end = rootPath[i + 1];\n                const neighbors = this.getNeighbors(start);\n                for (const neighbor of neighbors) {\n                    if (neighbor.node === end) {\n                        removedEdges.push({ start: start, end: end, weight: neighbor.weight });\n                        this.adjacencyList[start] = this.adjacencyList[start].filter(edge => edge.node !== end);\n                        break;\n                    }\n                }\n            }\n            return removedEdges;\n        }\n\n        restoreEdges(removedEdges) {\n            for (const edge of removedEdges) {\n                this.addEdge(edge.start, edge.end, edge.weight);\n            }\n        }\n    }\n\n    class PriorityQueue {\n        // создание нового экземпляра\n        constructor() {\n            this.items = [];\n        }\n\n        // устанавливает новый элемент в очередь по приоритету\n        enqueue(element, priority) {\n            this.items.push({ element, priority });\n            this.items.sort((a, b) => a.priority - b.priority);\n        }\n\n        // удаляет самый приоритетный элемент - возвращает его же\n        dequeue() {\n            return this.items.shift();\n        }\n\n        // проверка на пустоту\n        isEmpty() {\n            return this.items.length === 0;\n        }\n    }\n    `;\n\n\n    return (\n        <div class = \"main_CodeBlock\">\n            <h2>Поиск k наименьших путей в графе на JavaScript</h2>\n            <SyntaxHighlighter language=\"javascript\" style={oneDark} showLineNumbers={true}>\n                {codeString}\n            </SyntaxHighlighter>\n        </div>\n    );\n};\n\nexport default CodeBlock;\n"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,KAAK,IAAIC,iBAAiB,QAAQ,0BAA0B;AACrE,SAASC,OAAO,QAAQ,gDAAgD;AACxE,OAAO,iBAAiB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAGzB,MAAMC,SAAS,GAAGA,CAAA,KAAM;EACpB,MAAMC,UAAU,GAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EAGD,oBACIF,OAAA;IAAKG,KAAK,EAAG,gBAAgB;IAAAC,QAAA,gBACzBJ,OAAA;MAAAI,QAAA,EAAI;IAA8C;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAI,CAAC,eACvDR,OAAA,CAACH,iBAAiB;MAACY,QAAQ,EAAC,YAAY;MAACC,KAAK,EAAEZ,OAAQ;MAACa,eAAe,EAAE,IAAK;MAAAP,QAAA,EAC1EF;IAAU;MAAAG,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACI,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACnB,CAAC;AAEd,CAAC;AAACI,EAAA,GAtMIX,SAAS;AAwMf,eAAeA,SAAS;AAAC,IAAAW,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}